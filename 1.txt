1. CPU utilisation in TLS vs KTLS vs KTLS-NIC Offload.
Since in TLS, cryptographic operations in handled in user space of the application, context switches occur between user space and kernel space, leading to increased CPU overhead. Multiple copies of data also increase the CPU usage.This frequent switching, along with encryption in user space, results in higher CPU utilization, slower performance, and increased latency.
But in KTLS, since encryption/decryption is done in the kernel, there are fewer context switches, leading to a significant reduction in CPU utilization.The application hands over the unencrypted data to the kernel, and the kernel handles both the network stack and cryptographic operations, improving efficiency and reducing CPU load.
KTLS-NIC Offload improves CPU utilisation further as NIC directly handles encryption and decryption, eliminating the need for the CPU to process any cryptographic tasks.This results in even lower CPU utilization, improved throughput, lower latency, and more efficient scaling in high-traffic environments.

3. Is KTLS useful when userspace stacks like VPP are used in place of Kernel stack?
KTLS can't be used with VPP because KTLS is a kernel-space feature, and VPP runs entirely in user space, bypassing the kernel's networking stack. In VPP, TLS processing is typically managed by user-space libraries like OpenSSL, and encrypted data is integrated into the VPP packet forwarding pipeline. KTLS only applies when the kernel is in control of the networking stack and manages TCP sockets, which VPP does not use.
Additionally, VPP uses DPDK, which provides direct, high-performance access to NICs from user space. This enables TLS offloading directly via NIC hardware using DPDK's CryptoDev or Security APIs, bypassing the need for kernel involvement or KTLS.
